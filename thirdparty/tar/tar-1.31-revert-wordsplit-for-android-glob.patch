diff --git a/lib/wordsplit.c b/lib/wordsplit.c
index 661a4f8..f2ecada 100644
--- a/lib/wordsplit.c
+++ b/lib/wordsplit.c
@@ -1,5 +1,5 @@
 /* wordsplit - a word splitter
-   Copyright (C) 2009-2018 Sergey Poznyakoff
+   Copyright (C) 2009-2014, 2016-2017 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
@@ -12,7 +12,10 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License along
-   with this program. If not, see <http://www.gnu.org/licenses/>. */
+   with this program. If not, see <http://www.gnu.org/licenses/>.
+
+   Written by Sergey Poznyakoff
+*/
 
 #ifdef HAVE_CONFIG_H
 # include <config.h>
@@ -25,8 +28,6 @@
 #include <string.h>
 #include <stdio.h>
 #include <stdarg.h>
-#include <pwd.h>
-#include <glob.h>
 
 #if ENABLE_NLS
 # include <gettext.h>
@@ -36,14 +37,6 @@
 #define _(msgid) gettext (msgid)
 #define N_(msgid) msgid
 
-#ifndef FALLTHROUGH
-# if __GNUC__ < 7
-#  define FALLTHROUGH ((void) 0)
-# else
-#  define FALLTHROUGH __attribute__ ((__fallthrough__))
-# endif
-#endif
-
 #include <wordsplit.h>
 
 #define ISWS(c) ((c)==' '||(c)=='\t'||(c)=='\n')
@@ -58,19 +51,13 @@
 #define ISALNUM(c) (ISALPHA(c) || ISDIGIT(c))
 #define ISPRINT(c) (' ' <= ((unsigned) (c)) && ((unsigned) (c)) <= 127)
 
-#define ISVARBEG(c) (ISALPHA(c) || c == '_')
-#define ISVARCHR(c) (ISALNUM(c) || c == '_')
-
-#define WSP_RETURN_DELIMS(wsp) \
- ((wsp)->ws_flags & WRDSF_RETURN_DELIMS || ((wsp)->ws_options & WRDSO_MAXWORDS))
-
 #define ALLOC_INIT 128
 #define ALLOC_INCR 128
 
 static void
 _wsplt_alloc_die (struct wordsplit *wsp)
 {
-  wsp->ws_error ("%s", _("memory exhausted"));
+  wsp->ws_error (_("memory exhausted"));
   abort ();
 }
 
@@ -87,15 +74,6 @@ _wsplt_error (const char *fmt, ...)
 
 static void wordsplit_free_nodes (struct wordsplit *);
 
-static int
-_wsplt_seterr (struct wordsplit *wsp, int ec)
-{
-  wsp->ws_errno = ec;
-  if (wsp->ws_flags & WRDSF_SHOWERR)
-    wordsplit_perror (wsp);
-  return ec;
-}
-  
 static int
 _wsplt_nomem (struct wordsplit *wsp)
 {
@@ -111,84 +89,6 @@ _wsplt_nomem (struct wordsplit *wsp)
   return wsp->ws_errno;
 }
 
-static int wordsplit_run (const char *command, size_t length,
-			  struct wordsplit *wsp,
-			  unsigned flags, int lvl);
-
-static int wordsplit_init (struct wordsplit *wsp, const char *input, size_t len,
-			   unsigned flags);
-static int wordsplit_process_list (struct wordsplit *wsp, size_t start);
-static int wordsplit_finish (struct wordsplit *wsp);
-
-static int
-_wsplt_subsplit (struct wordsplit *wsp, struct wordsplit *wss,
-		 char const *str, int len,
-		 unsigned flags, int finalize)
-{
-  int rc;
-  
-  wss->ws_delim = wsp->ws_delim;
-  wss->ws_debug = wsp->ws_debug;
-  wss->ws_error = wsp->ws_error;
-  wss->ws_alloc_die = wsp->ws_alloc_die;
-
-  if (!(flags & WRDSF_NOVAR))
-    {
-      wss->ws_env = wsp->ws_env;
-      wss->ws_getvar = wsp->ws_getvar;
-      flags |= wsp->ws_flags & (WRDSF_ENV | WRDSF_ENV_KV | WRDSF_GETVAR);
-    }
-  if (!(flags & WRDSF_NOCMD))
-    {
-      wss->ws_command = wsp->ws_command;
-    }
-
-  if ((flags & (WRDSF_NOVAR|WRDSF_NOCMD)) != (WRDSF_NOVAR|WRDSF_NOCMD))
-    {
-      wss->ws_closure = wsp->ws_closure;
-      flags |= wsp->ws_flags & WRDSF_CLOSURE;
-    }
-
-  wss->ws_options = wsp->ws_options;
-  
-  flags |= WRDSF_DELIM
-         | WRDSF_ALLOC_DIE
-         | WRDSF_ERROR
-         | WRDSF_DEBUG
-         | (wsp->ws_flags & (WRDSF_SHOWDBG | WRDSF_SHOWERR | WRDSF_OPTIONS));
-
-  rc = wordsplit_init (wss, str, len, flags);
-  if (rc)
-    return rc;
-  wss->ws_lvl = wsp->ws_lvl + 1;
-  rc = wordsplit_process_list (wss, 0);
-  if (rc)
-    {
-      wordsplit_free_nodes (wss);
-      return rc;
-    }
-  if (finalize)
-    {
-      rc = wordsplit_finish (wss);
-      wordsplit_free_nodes (wss);
-    }
-  return rc;
-}
-
-static void
-_wsplt_seterr_sub (struct wordsplit *wsp, struct wordsplit *wss)
-{
-  if (wsp->ws_errno == WRDSE_USERERR)
-    free (wsp->ws_usererr);
-  wsp->ws_errno = wss->ws_errno;
-  if (wss->ws_errno == WRDSE_USERERR)
-    {
-      wsp->ws_usererr = wss->ws_usererr;
-      wss->ws_errno = WRDSE_EOF;
-      wss->ws_usererr = NULL;
-    }
-}
-
 static void
 wordsplit_init0 (struct wordsplit *wsp)
 {
@@ -196,7 +96,6 @@ wordsplit_init0 (struct wordsplit *wsp)
     {
       if (!(wsp->ws_flags & WRDSF_APPEND))
 	wordsplit_free_words (wsp);
-      wordsplit_clearerr (wsp);
     }
   else
     {
@@ -206,13 +105,12 @@ wordsplit_init0 (struct wordsplit *wsp)
     }
 
   wsp->ws_errno = 0;
+  wsp->ws_head = wsp->ws_tail = NULL;
 }
 
-char wordsplit_c_escape_tab[] = "\\\\\"\"a\ab\bf\fn\nr\rt\tv\v";
-  
 static int
 wordsplit_init (struct wordsplit *wsp, const char *input, size_t len,
-		unsigned flags)
+		int flags)
 {
   wsp->ws_flags = flags;
 
@@ -221,21 +119,23 @@ wordsplit_init (struct wordsplit *wsp, const char *input, size_t len,
   if (!(wsp->ws_flags & WRDSF_ERROR))
     wsp->ws_error = _wsplt_error;
 
-  if (!(wsp->ws_flags & WRDSF_NOVAR))
+  if (!(wsp->ws_flags & WRDSF_NOVAR)
+      && !(wsp->ws_flags & (WRDSF_ENV | WRDSF_GETVAR)))
     {
-      /* These will be initialized on first variable assignment */
-      wsp->ws_envidx = wsp->ws_envsiz = 0;
-      wsp->ws_envbuf = NULL;
+      errno = EINVAL;
+      wsp->ws_errno = WRDSE_USAGE;
+      if (wsp->ws_flags & WRDSF_SHOWERR)
+	wordsplit_perror (wsp);
+      return wsp->ws_errno;
     }
 
   if (!(wsp->ws_flags & WRDSF_NOCMD))
     {
-      if (!wsp->ws_command)
-	{
-	  _wsplt_seterr (wsp, WRDSE_USAGE);
-	  errno = EINVAL;
-	  return wsp->ws_errno;
-	}
+      errno = EINVAL;
+      wsp->ws_errno = WRDSE_NOSUPP;
+      if (wsp->ws_flags & WRDSF_SHOWERR)
+	wordsplit_perror (wsp);
+      return wsp->ws_errno;
     }
 
   if (wsp->ws_flags & WRDSF_SHOWDBG)
@@ -266,42 +166,10 @@ wordsplit_init (struct wordsplit *wsp, const char *input, size_t len,
   if (!(wsp->ws_flags & WRDSF_CLOSURE))
     wsp->ws_closure = NULL;
 
-  if (!(wsp->ws_flags & WRDSF_OPTIONS))
-    wsp->ws_options = 0;
-
-  if (wsp->ws_flags & WRDSF_ESCAPE)
-    {
-      if (!wsp->ws_escape[WRDSX_WORD])
-	wsp->ws_escape[WRDSX_WORD] = "";
-      if (!wsp->ws_escape[WRDSX_QUOTE])
-	wsp->ws_escape[WRDSX_QUOTE] = "";
-    }
-  else
-    {
-      if (wsp->ws_flags & WRDSF_CESCAPES)
-	{
-	  wsp->ws_escape[WRDSX_WORD] = wordsplit_c_escape_tab;
-	  wsp->ws_escape[WRDSX_QUOTE] = wordsplit_c_escape_tab;
-	  wsp->ws_options |= WRDSO_OESC_QUOTE | WRDSO_OESC_WORD       
-	                     | WRDSO_XESC_QUOTE | WRDSO_XESC_WORD;
-	}
-      else
-	{
-	  wsp->ws_escape[WRDSX_WORD] = "";
-	  wsp->ws_escape[WRDSX_QUOTE] = "\\\\\"\"";
-	  wsp->ws_options |= WRDSO_BSKEEP_QUOTE;
-	}
-    }
-  
   wsp->ws_endp = 0;
-  wsp->ws_wordi = 0;
 
-  if (wsp->ws_flags & WRDSF_REUSE)
-    wordsplit_free_nodes (wsp);
-  wsp->ws_head = wsp->ws_tail = NULL;
-  
   wordsplit_init0 (wsp);
-  
+
   return 0;
 }
 
@@ -344,7 +212,6 @@ alloc_space (struct wordsplit *wsp, size_t count)
 #define _WSNF_NOEXPAND 0x08	/* text is not subject to expansion */
 #define _WSNF_JOIN     0x10	/* node must be joined with the next node */
 #define _WSNF_SEXP     0x20	/* is a sed expression */
-#define _WSNF_DELIM    0x40     /* node is a delimiter */
 
 #define _WSNF_EMPTYOK  0x0100	/* special flag indicating that
 				   wordsplit_add_segm must add the
@@ -367,9 +234,9 @@ struct wordsplit_node
 };
 
 static const char *
-wsnode_flagstr (unsigned flags)
+wsnode_flagstr (int flags)
 {
-  static char retbuf[7];
+  static char retbuf[6];
   char *p = retbuf;
 
   if (flags & _WSNF_WORD)
@@ -394,10 +261,6 @@ wsnode_flagstr (unsigned flags)
     *p++ = 's';
   else
     *p++ = '-';
-  if (flags & _WSNF_DELIM)
-    *p++ = 'd';
-  else
-    *p++ = '-';
   *p = 0;
   return retbuf;
 }
@@ -478,14 +341,6 @@ wsnode_remove (struct wordsplit *wsp, struct wordsplit_node *node)
   node->next = node->prev = NULL;
 }
 
-static struct wordsplit_node *
-wsnode_tail (struct wordsplit_node *p)
-{
-  while (p && p->next)
-    p = p->next;
-  return p;
-}
-
 static void
 wsnode_insert (struct wordsplit *wsp, struct wordsplit_node *node,
 	       struct wordsplit_node *anchor, int before)
@@ -501,24 +356,22 @@ wsnode_insert (struct wordsplit *wsp, struct wordsplit_node *node,
 	wsnode_insert (wsp, node, anchor->prev, 0);
       else
 	{
-	  struct wordsplit_node *tail = wsnode_tail (node);
 	  node->prev = NULL;
-	  tail->next = anchor;
-	  anchor->prev = tail;
+	  node->next = anchor;
+	  anchor->prev = node;
 	  wsp->ws_head = node;
 	}
     }
   else
     {
       struct wordsplit_node *p;
-      struct wordsplit_node *tail = wsnode_tail (node);
 
       p = anchor->next;
       if (p)
-	p->prev = tail;
+	p->prev = node;
       else
-	wsp->ws_tail = tail;
-      tail->next = p;
+	wsp->ws_tail = node;
+      node->next = p;
       node->prev = anchor;
       anchor->next = node;
     }
@@ -565,12 +418,10 @@ wordsplit_dump_nodes (struct wordsplit *wsp)
   for (p = wsp->ws_head, n = 0; p; p = p->next, n++)
     {
       if (p->flags & _WSNF_WORD)
-	wsp->ws_debug ("(%02d) %4d: %p: %#04x (%s):%s;",
-		       wsp->ws_lvl,
+	wsp->ws_debug ("%4d: %p: %#04x (%s):%s;",
 		       n, p, p->flags, wsnode_flagstr (p->flags), p->v.word);
       else
-	wsp->ws_debug ("(%02d) %4d: %p: %#04x (%s):%.*s;",
-		       wsp->ws_lvl,
+	wsp->ws_debug ("%4d: %p: %#04x (%s):%.*s;",
 		       n, p, p->flags, wsnode_flagstr (p->flags),
 		       (int) (p->v.segm.end - p->v.segm.beg),
 		       wsp->ws_input + p->v.segm.beg);
@@ -585,15 +436,11 @@ coalesce_segment (struct wordsplit *wsp, struct wordsplit_node *node)
   char *buf, *cur;
   int stop;
 
-  if (!(node->flags & _WSNF_JOIN))
-    return 0;
-  
   for (p = node; p && (p->flags & _WSNF_JOIN); p = p->next)
     {
       len += wsnode_len (p);
     }
-  if (p)
-    len += wsnode_len (p);
+  len += wsnode_len (p);
   end = p;
 
   buf = malloc (len + 1);
@@ -612,7 +459,6 @@ coalesce_segment (struct wordsplit *wsp, struct wordsplit_node *node)
       cur += slen;
       if (p != node)
 	{
-	  node->flags |= p->flags & _WSNF_QUOTE;
 	  wsnode_remove (wsp, p);
 	  stop = p == end;
 	  wsnode_free (p);
@@ -632,14 +478,13 @@ coalesce_segment (struct wordsplit *wsp, struct wordsplit_node *node)
   return 0;
 }
 
-static void wordsplit_string_unquote_copy (struct wordsplit *ws, int inquote,
-					   char *dst, const char *src,
-					   size_t n);
-
 static int
 wsnode_quoteremoval (struct wordsplit *wsp)
 {
   struct wordsplit_node *p;
+  void (*uqfn) (char *, const char *, size_t) =
+    (wsp->ws_flags & WRDSF_CESCAPES) ?
+    wordsplit_c_unquote_copy : wordsplit_sh_unquote_copy;
 
   for (p = wsp->ws_head; p; p = p->next)
     {
@@ -648,7 +493,9 @@ wsnode_quoteremoval (struct wordsplit *wsp)
       int unquote;
 
       if (wsp->ws_flags & WRDSF_QUOTE)
-	unquote = !(p->flags & _WSNF_NOEXPAND);
+	{
+	  unquote = !(p->flags & _WSNF_NOEXPAND);
+	}
       else
 	unquote = 0;
 
@@ -665,8 +512,11 @@ wsnode_quoteremoval (struct wordsplit *wsp)
 	      p->flags |= _WSNF_WORD;
 	    }
 
-	  wordsplit_string_unquote_copy (wsp, p->flags & _WSNF_QUOTE,
-					 p->v.word, str, slen);
+	  if (wsp->ws_flags & WRDSF_ESCAPE)
+	    wordsplit_general_unquote_copy (p->v.word, str, slen,
+				            wsp->ws_escape);
+	  else
+	    uqfn (p->v.word, str, slen);
 	}
     }
   return 0;
@@ -686,161 +536,24 @@ wsnode_coalesce (struct wordsplit *wsp)
   return 0;
 }
 
-static int
-wsnode_tail_coalesce (struct wordsplit *wsp, struct wordsplit_node *p)
-{
-  if (p->next)
-    {
-      struct wordsplit_node *np = p;
-      while (np && np->next)
-	{
-	  np->flags |= _WSNF_JOIN;
-	  np = np->next;
-	}
-      if (coalesce_segment (wsp, p))
-	return 1;
-    }
-  return 0;
-}
-
-static size_t skip_delim (struct wordsplit *wsp);
-
 static int
 wordsplit_finish (struct wordsplit *wsp)
 {
   struct wordsplit_node *p;
   size_t n;
-  int delim;
-
-  /* Postprocess delimiters. It would be rather simple, if it weren't for
-     the incremental operation.
-
-     Nodes of type _WSNF_DELIM get inserted to the node list if either
-     WRDSF_RETURN_DELIMS flag or WRDSO_MAXWORDS option is set.
-     
-     The following cases should be distinguished:
-
-     1. If both WRDSF_SQUEEZE_DELIMS and WRDSF_RETURN_DELIMS are set, compress
-        any runs of similar delimiter nodes to a single node. The nodes are
-	'similar' if they point to the same delimiter character.
-
-	If WRDSO_MAXWORDS option is set, stop compressing when
-	ws_wordi + 1 == ws_maxwords, and coalesce the rest of nodes into
-	a single last node.
-
-     2. If WRDSO_MAXWORDS option is set, but WRDSF_RETURN_DELIMS is not,
-        remove any delimiter nodes. Stop operation when
-	ws_wordi + 1 == ws_maxwords, and coalesce the rest of nodes into
-	a single last node.
-
-     3. If incremental operation is in progress, restart the loop any time
-        a delimiter node is about to be returned, unless WRDSF_RETURN_DELIMS
-	is set.
-  */
- again:
-  delim = 0;         /* Delimiter being processed (if any) */
-  n = 0;             /* Number of words processed so far */
-  p = wsp->ws_head;  /* Current node */
-
-  while (p)
-    {
-      struct wordsplit_node *next = p->next;
-      if (p->flags & _WSNF_DELIM)
-	{
-	  if (wsp->ws_flags & WRDSF_RETURN_DELIMS)
-	    {
-	      if (wsp->ws_flags & WRDSF_SQUEEZE_DELIMS)
-		{
-		  char const *s = wsnode_ptr (wsp, p);
-		  if (delim)
-		    {
-		      if (delim == *s)
-			{
-			  wsnode_remove (wsp, p);
-			  p = next;
-			  continue;
-			}
-		      else
-			{
-			  delim = 0;
-			  n++; /* Count this node; it will be returned */
-			}
-		    }
-		  else
-		    {
-		      delim = *s;
-		      p = next;
-		      continue;
-		    }
-		}
-	    }
-	  else if (wsp->ws_options & WRDSO_MAXWORDS)
-	    {
-	      wsnode_remove (wsp, p);
-	      p = next;
-	      continue;
-	    }
-	}
-      else 
-	{
-	  if (delim)
-	    {
-	      /* Last node was a delimiter or a compressed run of delimiters;
-		 Count it, and clear the delimiter marker */
-	      n++;
-	      delim = 0;
-	    }
-	  if (wsp->ws_options & WRDSO_MAXWORDS)
-	    {
-	      if (wsp->ws_wordi + n + 1 == wsp->ws_maxwords)
-		break;
-	    }
-	}
-      n++;
-      if (wsp->ws_flags & WRDSF_INCREMENTAL)
-	p = NULL; /* Break the loop */
-      else
-	p = next;
-    }
 
-  if (p)
-    {
-      /* We're here if WRDSO_MAXWORDS is in effect and wsp->ws_maxwords
-	 words have already been collected. Reconstruct a single final
-	 node from the remaining nodes. */
-      if (wsnode_tail_coalesce (wsp, p))
-	return wsp->ws_errno;
-      n++;
-    }
+  n = 0;
 
-  if (n == 0 && (wsp->ws_flags & WRDSF_INCREMENTAL))
-    {
-      /* The loop above have eliminated all nodes. Restart the
-	 processing, if there's any input left. */
-      if (wsp->ws_endp < wsp->ws_len)
-	{
-	  int rc;
-	  if (wsp->ws_flags & WRDSF_SHOWDBG)
-	    wsp->ws_debug (_("Restarting"));
-	  rc = wordsplit_process_list (wsp, skip_delim (wsp));
-	  if (rc)
-	    return rc;
-	}
-      else
-	{
-	  wsp->ws_error = WRDSE_EOF;
-	  return WRDSE_EOF;
-	}
-      goto again;
-    }
+  for (p = wsp->ws_head; p; p = p->next)
+    n++;
 
   if (alloc_space (wsp, n + 1))
-    return wsp->ws_errno;
+    return 1;
 
-  while (wsp->ws_head)
+  for (p = wsp->ws_head; p; p = p->next)
     {
-      const char *str = wsnode_ptr (wsp, wsp->ws_head);
-      size_t slen = wsnode_len (wsp->ws_head);
+      const char *str = wsnode_ptr (wsp, p);
+      size_t slen = wsnode_len (p);
       char *newstr = malloc (slen + 1);
 
       /* Assign newstr first, even if it is NULL.  This way
@@ -852,47 +565,14 @@ wordsplit_finish (struct wordsplit *wsp)
       memcpy (newstr, str, slen);
       newstr[slen] = 0;
 
-      wsnode_remove (wsp, wsp->ws_head);
-
       wsp->ws_wordc++;
-      wsp->ws_wordi++;
 
-      if (wsp->ws_flags & WRDSF_INCREMENTAL)
-	break;
     }
   wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc] = NULL;
   return 0;
 }
 
-int
-wordsplit_append (wordsplit_t *wsp, int argc, char **argv)
-{
-  int rc;
-  size_t i;
 
-  rc = alloc_space (wsp, wsp->ws_wordc + argc + 1);
-  if (rc)
-    return rc;
-  for (i = 0; i < argc; i++)
-    {
-      char *newstr = strdup (argv[i]);
-      if (!newstr)
-	{
-	  while (i > 0)
-	    {
-	      free (wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc + i - 1]);
-	      wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc + i - 1] = NULL;
-	      i--;
-	    }
-	  return _wsplt_nomem (wsp);
-	}
-      wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc + i] = newstr;
-    }
-  wsp->ws_wordc += i;
-  wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc] = NULL;
-  return 0;
-}
-
 /* Variable expansion */
 static int
 node_split_prefix (struct wordsplit *wsp,
@@ -929,10 +609,10 @@ node_split_prefix (struct wordsplit *wsp,
 }
 
 static int
-find_closing_paren (const char *str, size_t i, size_t len, size_t *poff,
-		    char const *paren)
+find_closing_cbrace (const char *str, size_t i, size_t len, size_t * poff)
 {
-  enum { st_init, st_squote, st_dquote } state = st_init;
+  enum
+  { st_init, st_squote, st_dquote } state = st_init;
   size_t level = 1;
 
   for (; i < len; i++)
@@ -942,23 +622,18 @@ find_closing_paren (const char *str, size_t i, size_t len, size_t *poff,
 	case st_init:
 	  switch (str[i])
 	    {
-	    default:
-	      if (str[i] == paren[0])
-		{
-		  level++;
-		  break;
-		}
-	      else if (str[i] == paren[1])
+	    case '{':
+	      level++;
+	      break;
+
+	    case '}':
+	      if (--level == 0)
 		{
-		  if (--level == 0)
-		    {
-		      *poff = i;
-		      return 0;
-		    }
-		  break;
+		  *poff = i;
+		  return 0;
 		}
 	      break;
-	      
+
 	    case '"':
 	      state = st_dquote;
 	      break;
@@ -985,14 +660,13 @@ find_closing_paren (const char *str, size_t i, size_t len, size_t *poff,
   return 1;
 }
 
-static int
-wordsplit_find_env (struct wordsplit *wsp, const char *name, size_t len,
-		    char const **ret)
+static const char *
+wordsplit_find_env (struct wordsplit *wsp, const char *name, size_t len)
 {
   size_t i;
 
   if (!(wsp->ws_flags & WRDSF_ENV))
-    return WRDSE_UNDEF;
+    return NULL;
 
   if (wsp->ws_flags & WRDSF_ENV_KV)
     {
@@ -1001,17 +675,14 @@ wordsplit_find_env (struct wordsplit *wsp, const char *name, size_t len,
 	{
 	  size_t elen = strlen (wsp->ws_env[i]);
 	  if (elen == len && memcmp (wsp->ws_env[i], name, elen) == 0)
-	    {
-	      *ret = wsp->ws_env[i + 1];
-	      return WRDSE_OK;
-	    }
+	    return wsp->ws_env[i + 1];
 	  /* Skip the value.  Break the loop if it is NULL. */
 	  i++;
 	  if (wsp->ws_env[i] == NULL)
 	    break;
 	}
     }
-  else if (wsp->ws_env)
+  else
     {
       /* Usual (A=B) environment. */
       for (i = 0; wsp->ws_env[i]; i++)
@@ -1023,137 +694,27 @@ wordsplit_find_env (struct wordsplit *wsp, const char *name, size_t len,
 	    if (name[j] != var[j])
 	      break;
 	  if (j == len && var[j] == '=')
-	    {
-	      *ret = var + j + 1;
-	      return WRDSE_OK;
-	    }
-	}
-    }
-  return WRDSE_UNDEF;
-}
-
-static int
-wsplt_assign_var (struct wordsplit *wsp, const char *name, size_t namelen,
-		  char *value)
-{
-  int n = (wsp->ws_flags & WRDSF_ENV_KV) ? 2 : 1;
-  char *v;
-  
-  if (wsp->ws_envidx + n >= wsp->ws_envsiz)
-    {
-      size_t sz;
-      char **newenv;
-
-      if (!wsp->ws_envbuf)
-	{
-	  if (wsp->ws_flags & WRDSF_ENV)
-	    {
-	      size_t i = 0, j;
-
-	      if (wsp->ws_env)
-		{
-		  for (; wsp->ws_env[i]; i++)
-		    ;
-		}
-	      
-	      sz = i + n + 1;
-
-	      newenv = calloc (sz, sizeof(newenv[0]));
-	      if (!newenv)
-		return _wsplt_nomem (wsp);
-
-	      for (j = 0; j < i; j++)
-		{
-		  newenv[j] = strdup (wsp->ws_env[j]);
-		  if (!newenv[j])
-		    {
-		      for (; j > 1; j--)
-			free (newenv[j-1]);
-		      free (newenv[j-1]);
-		      free (newenv);
-		      return _wsplt_nomem (wsp);
-		    }
-		}
-	      newenv[j] = NULL;
-	      
-	      wsp->ws_envbuf = newenv;
-	      wsp->ws_envidx = i;
-	      wsp->ws_envsiz = sz;
-	      wsp->ws_env = (const char**) wsp->ws_envbuf;
-	    }
-	  else
-	    {
-	      newenv = calloc (WORDSPLIT_ENV_INIT, sizeof(newenv[0]));
-	      if (!newenv)
-		return _wsplt_nomem (wsp);
-	      wsp->ws_envbuf = newenv;
-	      wsp->ws_envidx = 0;
-	      wsp->ws_envsiz = WORDSPLIT_ENV_INIT;
-	      wsp->ws_env = (const char**) wsp->ws_envbuf;
-	      wsp->ws_flags |= WRDSF_ENV;
-	    }
-	}
-      else
-	{
-	  wsp->ws_envsiz *= 2;
-	  newenv = realloc (wsp->ws_envbuf,
-			    wsp->ws_envsiz * sizeof (wsp->ws_envbuf[0]));
-	  if (!newenv)
-	    return _wsplt_nomem (wsp);
-	  wsp->ws_envbuf = newenv;
-	  wsp->ws_env = (const char**) wsp->ws_envbuf;
-	}
-    }
-  
-  if (wsp->ws_flags & WRDSF_ENV_KV)
-    {
-      /* A key-value pair environment */
-      char *p = malloc (namelen + 1);
-      if (!p)
-	return _wsplt_nomem (wsp);
-      memcpy (p, name, namelen);
-      p[namelen] = 0;
-
-      v = strdup (value);
-      if (!v)
-	{
-	  free (p);
-	  return _wsplt_nomem (wsp);
+	    return var + j + 1;
 	}
-      wsp->ws_env[wsp->ws_envidx++] = p;
-      wsp->ws_env[wsp->ws_envidx++] = v;
-    }
-  else
-    {
-      v = malloc (namelen + strlen(value) + 2);
-      if (!v)
-	return _wsplt_nomem (wsp);
-      memcpy (v, name, namelen);
-      v[namelen++] = '=';
-      strcpy(v + namelen, value);
-      wsp->ws_env[wsp->ws_envidx++] = v;
     }
-  wsp->ws_env[wsp->ws_envidx++] = NULL;
-  return WRDSE_OK;
+  return NULL;
 }
 
 static int
 expvar (struct wordsplit *wsp, const char *str, size_t len,
-	struct wordsplit_node **ptail, const char **pend, unsigned flg)
+	struct wordsplit_node **ptail, const char **pend, int flg)
 {
   size_t i = 0;
   const char *defstr = NULL;
-  char *value;
+  const char *value;
   const char *vptr;
   struct wordsplit_node *newnode;
   const char *start = str - 1;
-  int rc;
-  struct wordsplit ws;
-  
-  if (ISVARBEG (str[0]))
+
+  if (ISALPHA (str[0]) || str[0] == '_')
     {
       for (i = 1; i < len; i++)
-	if (!ISVARCHR (str[i]))
+	if (!(ISALNUM (str[i]) || str[i] == '_'))
 	  break;
       *pend = str + i - 1;
     }
@@ -1162,36 +723,30 @@ expvar (struct wordsplit *wsp, const char *str, size_t len,
       str++;
       len--;
       for (i = 1; i < len; i++)
+	if (str[i] == '}' || str[i] == ':')
+	  break;
+      if (str[i] == ':')
 	{
-	  if (str[i] == ':')
-	    {
-	      size_t j;
-	      
-	      defstr = str + i + 1;
-	      if (find_closing_paren (str, i + 1, len, &j, "{}"))
-		return _wsplt_seterr (wsp, WRDSE_CBRACE);
-	      *pend = str + j;
-	      break;
-	    }
-	  else if (str[i] == '}')
-	    {
-	      defstr = NULL;
-	      *pend = str + i;
-	      break;
-	    }
-	  else if (strchr ("-+?=", str[i]))
+	  size_t j;
+
+	  defstr = str + i + 1;
+	  if (find_closing_cbrace (str, i + 1, len, &j))
 	    {
-	      size_t j;
-	      
-	      defstr = str + i;
-	      if (find_closing_paren (str, i, len, &j, "{}"))
-		return _wsplt_seterr (wsp, WRDSE_CBRACE);
-	      *pend = str + j;
-	      break;
+	      wsp->ws_errno = WRDSE_CBRACE;
+	      return 1;
 	    }
+	  *pend = str + j;
+	}
+      else if (str[i] == '}')
+	{
+	  defstr = NULL;
+	  *pend = str + i;
+	}
+      else
+	{
+	  wsp->ws_errno = WRDSE_CBRACE;
+	  return 1;
 	}
-      if (i == len)
-	return _wsplt_seterr (wsp, WRDSE_CBRACE);
     }
   else
     {
@@ -1215,161 +770,50 @@ expvar (struct wordsplit *wsp, const char *str, size_t len,
      i   - its length
      defstr - default replacement str */
 
-  if (defstr && strchr("-+?=", defstr[0]) == 0)
+  vptr = wordsplit_find_env (wsp, str, i);
+  if (vptr)
+    {
+      value = strdup (vptr);
+      if (!value)
+	return _wsplt_nomem (wsp);
+    }
+  else if (wsp->ws_flags & WRDSF_GETVAR)
+    value = wsp->ws_getvar (str, i, wsp->ws_closure);
+  else if (wsp->ws_flags & WRDSF_UNDEF)
     {
-      rc = WRDSE_UNDEF;
-      defstr = NULL;
+      wsp->ws_errno = WRDSE_UNDEF;
+      if (wsp->ws_flags & WRDSF_SHOWERR)
+	wordsplit_perror (wsp);
+      return 1;
     }
   else
     {
-      rc = wordsplit_find_env (wsp, str, i, &vptr);
-      if (rc == WRDSE_OK)
-	{
-	  if (vptr)
-	    {
-	      value = strdup (vptr);
-	      if (!value)
-		rc = WRDSE_NOSPACE;
-	    }
-	  else
-	    rc = WRDSE_UNDEF;
-	}
-      else if (wsp->ws_flags & WRDSF_GETVAR)
-	rc = wsp->ws_getvar (&value, str, i, wsp->ws_closure);
+      if (wsp->ws_flags & WRDSF_WARNUNDEF)
+	wsp->ws_error (_("warning: undefined variable `%.*s'"), (int) i, str);
+      if (wsp->ws_flags & WRDSF_KEEPUNDEF)
+	value = NULL;
       else
-	rc = WRDSE_UNDEF;
-
-      if (rc == WRDSE_OK
-	  && (!value || value[0] == 0)
-	  && defstr && defstr[-1] == ':')
-	{
-	  free (value);
-	  rc = WRDSE_UNDEF;
-	}
+	value = "";
     }
-  
-  switch (rc)
+
+  /* FIXME: handle defstr */
+  (void) defstr;
+
+  if (value)
     {
-    case WRDSE_OK:
-      if (defstr && *defstr == '+')
+      if (flg & _WSNF_QUOTE)
 	{
-	  size_t size = *pend - ++defstr;
-
-	  rc = _wsplt_subsplit (wsp, &ws, defstr, size,
-				WRDSF_NOSPLIT | WRDSF_WS | WRDSF_QUOTE |
-				(wsp->ws_flags &
-				 (WRDSF_NOVAR | WRDSF_NOCMD)), 1);
-	  if (rc)
-	    return rc;
-	  free (value);
-	  value = ws.ws_wordv[0];
-	  ws.ws_wordv[0] = NULL;
-	  wordsplit_free (&ws);
+	  if (wsnode_new (wsp, &newnode))
+	    return 1;
+	  wsnode_insert (wsp, newnode, *ptail, 0);
+	  *ptail = newnode;
+	  newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;
+	  newnode->v.word = strdup (value);
+	  if (!newnode->v.word)
+	    return _wsplt_nomem (wsp);
 	}
-      break;
-      
-    case WRDSE_UNDEF:
-      if (defstr)
+      else if (*value == 0)
 	{
-	  size_t size;
-	  if (*defstr == '-' || *defstr == '=')
-	    {
-	      size = *pend - ++defstr;
-
-	      rc = _wsplt_subsplit (wsp, &ws, defstr, size,
-				    WRDSF_NOSPLIT | WRDSF_WS | WRDSF_QUOTE |
-				    (wsp->ws_flags &
-				     (WRDSF_NOVAR | WRDSF_NOCMD)),
-				    1);
-	      if (rc)
-		return rc;
-
-	      value = ws.ws_wordv[0];
-	      ws.ws_wordv[0] = NULL;
-	      wordsplit_free (&ws);
-	      
-	      if (defstr[-1] == '=')
-		wsplt_assign_var (wsp, str, i, value);
-	    }
-	  else 
-	    {
-	      if (*defstr == '?')
-		{
-		  size = *pend - ++defstr;
-		  if (size == 0)
-		    wsp->ws_error (_("%.*s: variable null or not set"),
-				   (int) i, str);
-		  else
-		    {
-		      rc = _wsplt_subsplit (wsp, &ws, defstr, size,
-					    WRDSF_NOSPLIT | WRDSF_WS |
-					    WRDSF_QUOTE |
-					    (wsp->ws_flags &
-					     (WRDSF_NOVAR | WRDSF_NOCMD)),
-					    1);
-		      if (rc == 0)
-			wsp->ws_error ("%.*s: %s",
-				       (int) i, str, ws.ws_wordv[0]);
-		      else
-			wsp->ws_error ("%.*s: %.*s",
-				       (int) i, str, (int) size, defstr);
-		      wordsplit_free (&ws);
-		    }
-		}
-	      value = NULL;
-	    }
-	}
-      else if (wsp->ws_flags & WRDSF_UNDEF)
-	{
-	  _wsplt_seterr (wsp, WRDSE_UNDEF);
-	  return 1;
-	}
-      else
-	{
-	  if (wsp->ws_flags & WRDSF_WARNUNDEF)
-	    wsp->ws_error (_("warning: undefined variable `%.*s'"),
-			   (int) i, str);
-	  if (wsp->ws_flags & WRDSF_KEEPUNDEF)
-	    value = NULL;
-	  else
-	    {
-	      value = strdup ("");
-	      if (!value)
-		return _wsplt_nomem (wsp);
-	    }
-	}
-      break;
-      
-    case WRDSE_NOSPACE:
-      return _wsplt_nomem (wsp);
-
-    case WRDSE_USERERR:
-      if (wsp->ws_errno == WRDSE_USERERR)
-	free (wsp->ws_usererr);
-      wsp->ws_usererr = value;
-      FALLTHROUGH;
-    default:
-      _wsplt_seterr (wsp, rc);
-      return 1;
-    }
-
-  if (value)
-    {
-      if (flg & _WSNF_QUOTE)
-	{
-	  if (wsnode_new (wsp, &newnode))
-	    {
-	      free (value);
-	      return 1;
-	    }
-	  wsnode_insert (wsp, newnode, *ptail, 0);
-	  *ptail = newnode;
-	  newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;
-	  newnode->v.word = value;
-	}
-      else if (*value == 0)
-	{
-	  free (value);
 	  /* Empty string is a special case */
 	  if (wsnode_new (wsp, &newnode))
 	    return 1;
@@ -1380,23 +824,28 @@ expvar (struct wordsplit *wsp, const char *str, size_t len,
       else
 	{
 	  struct wordsplit ws;
-	  int rc;
-	  
-	  rc = _wsplt_subsplit (wsp, &ws, value, strlen (value),
-				WRDSF_NOVAR | WRDSF_NOCMD |
-				WRDSF_QUOTE
-				| (WSP_RETURN_DELIMS (wsp) ? WRDSF_RETURN_DELIMS : 0) ,
-				0);
-	  free (value);
-	  if (rc)
+	  int i;
+
+	  ws.ws_delim = wsp->ws_delim;
+	  if (wordsplit (value, &ws,
+			 WRDSF_NOVAR | WRDSF_NOCMD | WRDSF_DELIM | WRDSF_WS))
 	    {
-	      _wsplt_seterr_sub (wsp, &ws);
 	      wordsplit_free (&ws);
 	      return 1;
 	    }
-	  wsnode_insert (wsp, ws.ws_head, *ptail, 0);
-	  *ptail = ws.ws_tail;
-	  ws.ws_head = ws.ws_tail = NULL;
+	  for (i = 0; i < ws.ws_wordc; i++)
+	    {
+	      if (wsnode_new (wsp, &newnode))
+		return 1;
+	      wsnode_insert (wsp, newnode, *ptail, 0);
+	      *ptail = newnode;
+	      newnode->flags = _WSNF_WORD |
+		_WSNF_NOEXPAND |
+		(i + 1 < ws.ws_wordc ? (flg & ~_WSNF_JOIN) : flg);
+	      newnode->v.word = strdup (ws.ws_wordv[i]);
+	      if (!newnode->v.word)
+		return _wsplt_nomem (wsp);
+	    }
 	  wordsplit_free (&ws);
 	}
     }
@@ -1427,19 +876,7 @@ expvar (struct wordsplit *wsp, const char *str, size_t len,
 }
 
 static int
-begin_var_p (int c)
-{
-  return c == '{' || ISVARBEG (c);
-}
-
-static int
-node_expand (struct wordsplit *wsp, struct wordsplit_node *node,
-	     int (*beg_p) (int),
-	     int (*ws_exp_fn) (struct wordsplit *wsp,
-			       const char *str, size_t len,
-			       struct wordsplit_node **ptail,
-			       const char **pend,
-			       unsigned flg))
+node_expand_vars (struct wordsplit *wsp, struct wordsplit_node *node)
 {
   const char *str = wsnode_ptr (wsp, node);
   size_t slen = wsnode_len (node);
@@ -1455,7 +892,7 @@ node_expand (struct wordsplit *wsp, struct wordsplit_node *node,
 	  p++;
 	  continue;
 	}
-      if (*p == '$' && beg_p (p[1]))
+      if (*p == '$')
 	{
 	  size_t n = p - str;
 
@@ -1464,8 +901,8 @@ node_expand (struct wordsplit *wsp, struct wordsplit_node *node,
 	  if (node_split_prefix (wsp, &tail, node, off, n, _WSNF_JOIN))
 	    return 1;
 	  p++;
-	  if (ws_exp_fn (wsp, p, slen - n, &tail, &p,
-			 node->flags & (_WSNF_JOIN | _WSNF_QUOTE)))
+	  if (expvar (wsp, p, slen - n, &tail, &p,
+		      node->flags & (_WSNF_JOIN | _WSNF_QUOTE)))
 	    return 1;
 	  off += p - str + 1;
 	  str = p + 1;
@@ -1476,7 +913,7 @@ node_expand (struct wordsplit *wsp, struct wordsplit_node *node,
       if (tail != node)
 	tail->flags |= _WSNF_JOIN;
       if (node_split_prefix (wsp, &tail, node, off, p - str,
-			     node->flags & (_WSNF_JOIN|_WSNF_QUOTE)))
+			     node->flags & _WSNF_JOIN))
 	return 1;
     }
   if (tail != node)
@@ -1486,8 +923,8 @@ node_expand (struct wordsplit *wsp, struct wordsplit_node *node,
     }
   return 0;
 }
-  
-/* Remove NULL nodes from the list */
+
+/* Remove NULL lists */
 static void
 wsnode_nullelim (struct wordsplit *wsp)
 {
@@ -1496,8 +933,6 @@ wsnode_nullelim (struct wordsplit *wsp)
   for (p = wsp->ws_head; p;)
     {
       struct wordsplit_node *next = p->next;
-      if (p->flags & _WSNF_DELIM && p->prev)
-	p->prev->flags &= ~_WSNF_JOIN;
       if (p->flags & _WSNF_NULL)
 	{
 	  wsnode_remove (wsp, p);
@@ -1512,140 +947,11 @@ wordsplit_varexp (struct wordsplit *wsp)
 {
   struct wordsplit_node *p;
 
-  for (p = wsp->ws_head; p;)
-    {
-      struct wordsplit_node *next = p->next;
-      if (!(p->flags & (_WSNF_NOEXPAND|_WSNF_DELIM)))
-	if (node_expand (wsp, p, begin_var_p, expvar))
-	  return 1;
-      p = next;
-    }
-
-  wsnode_nullelim (wsp);
-  return 0;
-}
-
-static int
-begin_cmd_p (int c)
-{
-  return c == '(';
-}
-
-static int
-expcmd (struct wordsplit *wsp, const char *str, size_t len,
-	struct wordsplit_node **ptail, const char **pend, unsigned flg)
-{
-  int rc;
-  size_t j;
-  char *value;
-  struct wordsplit_node *newnode;
-  
-  str++;
-  len--;
-
-  if (find_closing_paren (str, 0, len, &j, "()"))
-    {
-      _wsplt_seterr (wsp, WRDSE_PAREN);
-      return 1;
-    }
-
-  *pend = str + j;
-  if (wsp->ws_options & WRDSO_ARGV)
-    {
-      struct wordsplit ws;
-
-      rc = _wsplt_subsplit (wsp, &ws, str, j, WRDSF_WS | WRDSF_QUOTE, 1);
-      if (rc)
-	{
-	  _wsplt_seterr_sub (wsp, &ws);
-	  wordsplit_free (&ws);
-	  return 1;
-	}
-      rc = wsp->ws_command (&value, str, j, ws.ws_wordv, wsp->ws_closure);
-      wordsplit_free (&ws);
-    }
-  else
-    rc = wsp->ws_command (&value, str, j, NULL, wsp->ws_closure);
-  
-  if (rc == WRDSE_NOSPACE)
-    return _wsplt_nomem (wsp);
-  else if (rc)
-    {
-      if (rc == WRDSE_USERERR)
-	{
-	  if (wsp->ws_errno == WRDSE_USERERR)
-	    free (wsp->ws_usererr);
-	  wsp->ws_usererr = value;
-	}
-      _wsplt_seterr (wsp, rc);
-      return 1;
-    }
-
-  if (value)
-    {
-      if (flg & _WSNF_QUOTE)
-	{
-	  if (wsnode_new (wsp, &newnode))
-	    return 1;
-	  wsnode_insert (wsp, newnode, *ptail, 0);
-	  *ptail = newnode;
-	  newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;
-	  newnode->v.word = value;
-	}
-      else if (*value == 0)
-	{
-	  free (value);
-	  /* Empty string is a special case */
-	  if (wsnode_new (wsp, &newnode))
-	    return 1;
-	  wsnode_insert (wsp, newnode, *ptail, 0);
-	  *ptail = newnode;
-	  newnode->flags = _WSNF_NULL;
-	}
-      else
-	{
-	  struct wordsplit ws;
-	  int rc;
-
-	  rc = _wsplt_subsplit (wsp, &ws, value, strlen (value),
-				WRDSF_NOVAR | WRDSF_NOCMD
-				| WRDSF_WS | WRDSF_QUOTE
-				| (WSP_RETURN_DELIMS (wsp) ? WRDSF_RETURN_DELIMS : 0),
-				0);
-	  free (value);
-	  if (rc)
-	    {
-	      _wsplt_seterr_sub (wsp, &ws);
-	      wordsplit_free (&ws);
-	      return 1;
-	    }
-	  wsnode_insert (wsp, ws.ws_head, *ptail, 0);
-	  *ptail = ws.ws_tail;
-	  ws.ws_head = ws.ws_tail = NULL;
-	  wordsplit_free (&ws);
-	}
-    }
-  else
-    {
-      if (wsnode_new (wsp, &newnode))
-	return 1;
-      wsnode_insert (wsp, newnode, *ptail, 0);
-      *ptail = newnode;
-      newnode->flags = _WSNF_NULL;
-    }
-  return 0;
-}
-
-static int
-wordsplit_cmdexp (struct wordsplit *wsp)
-{
-  struct wordsplit_node *p;
-
   for (p = wsp->ws_head; p;)
     {
       struct wordsplit_node *next = p->next;
       if (!(p->flags & _WSNF_NOEXPAND))
-	if (node_expand (wsp, p, begin_cmd_p, expcmd))
+	if (node_expand_vars (wsp, p))
 	  return 1;
       p = next;
     }
@@ -1657,7 +963,7 @@ wordsplit_cmdexp (struct wordsplit *wsp)
 /* Strip off any leading and trailing whitespace.  This function is called
    right after the initial scanning, therefore it assumes that every
    node in the list is a text reference node. */
-static int
+static void
 wordsplit_trimws (struct wordsplit *wsp)
 {
   struct wordsplit_node *p;
@@ -1666,21 +972,14 @@ wordsplit_trimws (struct wordsplit *wsp)
     {
       size_t n;
 
-      if (!(p->flags & _WSNF_QUOTE))
-	{
-	  /* Skip leading whitespace: */
-	  for (n = p->v.segm.beg; n < p->v.segm.end && ISWS (wsp->ws_input[n]);
-	       n++)
-	    ;
-	  p->v.segm.beg = n;
-	}
-      
-      while (p->next && (p->flags & _WSNF_JOIN))
-	p = p->next;
-      
       if (p->flags & _WSNF_QUOTE)
 	continue;
-      
+
+      /* Skip leading whitespace: */
+      for (n = p->v.segm.beg; n < p->v.segm.end && ISWS (wsp->ws_input[n]);
+	   n++)
+	;
+      p->v.segm.beg = n;
       /* Trim trailing whitespace */
       for (n = p->v.segm.end;
 	   n > p->v.segm.beg && ISWS (wsp->ws_input[n - 1]); n--);
@@ -1690,194 +989,6 @@ wordsplit_trimws (struct wordsplit *wsp)
     }
 
   wsnode_nullelim (wsp);
-  return 0;
-}
-
-static int
-wordsplit_tildexpand (struct wordsplit *wsp)
-{
-  struct wordsplit_node *p;
-  char *uname = NULL;
-  size_t usize = 0;
-  
-  for (p = wsp->ws_head; p; p = p->next)
-    {
-      const char *str;
-
-      if (p->flags & _WSNF_QUOTE)
-	continue;
-
-      str = wsnode_ptr (wsp, p);
-      if (str[0] == '~')
-	{
-	  size_t i, size, dlen;
-	  size_t slen = wsnode_len (p);
-	  struct passwd *pw;
-	  char *newstr;
-	  
-	  for (i = 1; i < slen && str[i] != '/'; i++)
-	    ;
-	  if (i == slen)
-	    continue;
-	  if (i > 1)
-	    {
-	      if (i > usize)
-		{
-		  char *p = realloc (uname, i);
-		  if (!p)
-		    {
-		      free (uname);
-		      return _wsplt_nomem (wsp);
-		    }
-		  uname = p;
-		  usize = i;
-		}
-	      --i;
-	      memcpy (uname, str + 1, i);
-	      uname[i] = 0;
-	      pw = getpwnam (uname);
-	    }
-	  else
-	    pw = getpwuid (getuid ());
-
-	  if (!pw)
-	    continue;
-
-	  dlen = strlen (pw->pw_dir);
-	  size = slen - i + dlen;
-	  newstr = malloc (size);
-	  if (!newstr)
-	    {
-	      free (uname);
-	      return _wsplt_nomem (wsp);
-	    }
-	  --size;
-
-	  memcpy (newstr, pw->pw_dir, dlen);
-	  memcpy (newstr + dlen, str + i + 1, slen - i - 1);
-	  newstr[size] = 0;
-	  if (p->flags & _WSNF_WORD)
-	    free (p->v.word);
-	  p->v.word = newstr;
-	  p->flags |= _WSNF_WORD;
-	}
-    }
-  free (uname);
-  return 0;
-}
-
-static int
-isglob (const char *s, int l)
-{
-  while (l--)
-    {
-      if (strchr ("*?[", *s++))
-	return 1;
-    }
-  return 0;
-}
-
-static int
-wordsplit_pathexpand (struct wordsplit *wsp)
-{
-  struct wordsplit_node *p, *next;
-  size_t slen;
-  int flags = 0;
-
-#ifdef GLOB_PERIOD
-  if (wsp->ws_options & WRDSO_DOTGLOB)
-    flags = GLOB_PERIOD;
-#endif
-  
-  for (p = wsp->ws_head; p; p = next)
-    {
-      const char *str;
-
-      next = p->next;
-
-      if (p->flags & _WSNF_QUOTE)
-	continue;
-
-      str = wsnode_ptr (wsp, p);
-      slen = wsnode_len (p);
-
-      if (isglob (str, slen))
-	{
-	  int i;
-	  glob_t g;
-	  struct wordsplit_node *prev;
-	  char *pattern;
-	  
-	  pattern = malloc (slen + 1);
-	  if (!pattern)
-	    return _wsplt_nomem (wsp);
-	  memcpy (pattern, str, slen);
-	  pattern[slen] = 0;
-      
-	  switch (glob (pattern, flags, NULL, &g))
-	    {
-	    case 0:
-	      free (pattern);
-	      break;
-	      
-	    case GLOB_NOSPACE:
-	      free (pattern);
-	      return _wsplt_nomem (wsp);
-	      
-	    case GLOB_NOMATCH:
-	      if (wsp->ws_options & WRDSO_NULLGLOB)
-		{
-		  wsnode_remove (wsp, p);
-		  wsnode_free (p);
-		}
-	      else if (wsp->ws_options & WRDSO_FAILGLOB)
-		{
-		  char buf[128];
-		  if (wsp->ws_errno == WRDSE_USERERR)
-		    free (wsp->ws_usererr);
-		  snprintf (buf, sizeof (buf), _("no files match pattern %s"),
-			    pattern);
-		  free (pattern);
-		  wsp->ws_usererr = strdup (buf);
-		  if (!wsp->ws_usererr)
-		    return _wsplt_nomem (wsp);
-		  else
-		    return _wsplt_seterr (wsp, WRDSE_USERERR);
-		}
-	      free (pattern);
-	      continue;
-	      
-	    default:
-	      free (pattern);
-	      return _wsplt_seterr (wsp, WRDSE_GLOBERR);
-	    }
-
-	  prev = p;
-	  for (i = 0; i < g.gl_pathc; i++)
-	    {
-	      struct wordsplit_node *newnode;
-	      char *newstr;
-	      
-	      if (wsnode_new (wsp, &newnode))
-		return 1;
-	      newstr = strdup (g.gl_pathv[i]);
-	      if (!newstr)
-		{
-		  wsnode_free (newnode);
-		  return _wsplt_nomem (wsp);
-		}
-	      newnode->v.word = newstr;
-	      newnode->flags |= _WSNF_WORD|_WSNF_QUOTE;
-	      wsnode_insert (wsp, newnode, prev, 0);
-	      prev = newnode;
-	    }
-	  globfree (&g);
-
-	  wsnode_remove (wsp, p);
-	  wsnode_free (p);
-	}
-    }
-  return 0;
 }
 
 static int
@@ -1913,24 +1024,33 @@ skip_sed_expr (const char *command, size_t i, size_t len)
   return i;
 }
 
-/* wsp->ws_endp points to a delimiter character. If RETURN_DELIMS
-   is true, return its value, otherwise return the index past it. */
-static inline size_t
-skip_delim_internal (struct wordsplit *wsp, int return_delims)
-{
-  return return_delims ? wsp->ws_endp : wsp->ws_endp + 1;
-}
-
-static inline size_t
+static size_t
 skip_delim (struct wordsplit *wsp)
 {
-  return skip_delim_internal (wsp, WSP_RETURN_DELIMS (wsp));
-}
+  size_t start = wsp->ws_endp;
+  if (wsp->ws_flags & WRDSF_SQUEEZE_DELIMS)
+    {
+      if ((wsp->ws_flags & WRDSF_RETURN_DELIMS) &&
+	  ISDELIM (wsp, wsp->ws_input[start]))
+	{
+	  int delim = wsp->ws_input[start];
+	  do
+	    start++;
+	  while (start < wsp->ws_len && delim == wsp->ws_input[start]);
+	}
+      else
+	{
+	  do
+	    start++;
+	  while (start < wsp->ws_len && ISDELIM (wsp, wsp->ws_input[start]));
+	}
+      start--;
+    }
 
-static inline size_t
-skip_delim_real (struct wordsplit *wsp)
-{
-  return skip_delim_internal (wsp, wsp->ws_flags & WRDSF_RETURN_DELIMS);
+  if (!(wsp->ws_flags & WRDSF_RETURN_DELIMS))
+    start++;
+
+  return start;
 }
 
 #define _WRDS_EOF   0
@@ -1938,7 +1058,7 @@ skip_delim_real (struct wordsplit *wsp)
 #define _WRDS_ERR   2
 
 static int
-scan_qstring (struct wordsplit *wsp, size_t start, size_t *end)
+scan_qstring (struct wordsplit *wsp, size_t start, size_t * end)
 {
   size_t j;
   const char *command = wsp->ws_input;
@@ -1950,7 +1070,7 @@ scan_qstring (struct wordsplit *wsp, size_t start, size_t *end)
       j++;
   if (j < len && command[j] == q)
     {
-      unsigned flags = _WSNF_QUOTE | _WSNF_EMPTYOK;
+      int flags = _WSNF_QUOTE | _WSNF_EMPTYOK;
       if (q == '\'')
 	flags |= _WSNF_NOEXPAND;
       if (wordsplit_add_segm (wsp, start + 1, j, flags))
@@ -1960,22 +1080,23 @@ scan_qstring (struct wordsplit *wsp, size_t start, size_t *end)
   else
     {
       wsp->ws_endp = start;
-      _wsplt_seterr (wsp, WRDSE_QUOTE);
+      wsp->ws_errno = WRDSE_QUOTE;
+      if (wsp->ws_flags & WRDSF_SHOWERR)
+	wordsplit_perror (wsp);
       return _WRDS_ERR;
     }
   return 0;
 }
 
 static int
-scan_word (struct wordsplit *wsp, size_t start, int consume_all)
+scan_word (struct wordsplit *wsp, size_t start)
 {
   size_t len = wsp->ws_len;
   const char *command = wsp->ws_input;
   const char *comment = wsp->ws_comment;
   int join = 0;
-  unsigned flags = 0;
-  struct wordsplit_node *np = wsp->ws_tail;
-  
+  int flags = 0;
+
   size_t i = start;
 
   if (i >= len)
@@ -1992,7 +1113,7 @@ scan_word (struct wordsplit *wsp, size_t start, int consume_all)
       flags = _WSNF_SEXP;
       i = skip_sed_expr (command, i, len);
     }
-  else if (consume_all || !ISDELIM (wsp, command[i]))
+  else if (!ISDELIM (wsp, command[i]))
     {
       while (i < len)
 	{
@@ -2031,28 +1152,15 @@ scan_word (struct wordsplit *wsp, size_t start, int consume_all)
 		}
 	    }
 
-	  if (command[i] == '$')
-	    {
-	      if (!(wsp->ws_flags & WRDSF_NOVAR)
-		  && command[i+1] == '{'
-		  && find_closing_paren (command, i + 2, len, &i, "{}") == 0)
-		continue;
-	      if (!(wsp->ws_flags & WRDSF_NOCMD)
-		  && command[i+1] == '('
-		  && find_closing_paren (command, i + 2, len, &i, "()") == 0)
-		continue;
-	    }
-
-	  if (!consume_all && ISDELIM (wsp, command[i]))
+	  if (ISDELIM (wsp, command[i]))
 	    break;
 	  else
 	    i++;
 	}
     }
-  else if (WSP_RETURN_DELIMS (wsp))
+  else if (wsp->ws_flags & WRDSF_RETURN_DELIMS)
     {
       i++;
-      flags |= _WSNF_DELIM;
     }
   else if (!(wsp->ws_flags & WRDSF_SQUEEZE_DELIMS))
     flags |= _WSNF_EMPTYOK;
@@ -2064,19 +1172,36 @@ scan_word (struct wordsplit *wsp, size_t start, int consume_all)
   wsp->ws_endp = i;
   if (wsp->ws_flags & WRDSF_INCREMENTAL)
     return _WRDS_EOF;
-  
-  if (consume_all)
+  return _WRDS_OK;
+}
+
+static char quote_transtab[] = "\\\\\"\"a\ab\bf\fn\nr\rt\tv\v";
+
+int
+wordsplit_c_unquote_char (int c)
+{
+  char *p;
+
+  for (p = quote_transtab; *p; p += 2)
     {
-      if (!np)
-	np = wsp->ws_head;
-      while (np)
-	{
-	  np->flags |= _WSNF_QUOTE;
-	  np = np->next;
-	}
+      if (*p == c)
+	return p[1];
     }
-  
-  return _WRDS_OK;
+  return c;
+}
+
+int
+wordsplit_c_quote_char (int c)
+{
+  char *p;
+
+  for (p = quote_transtab + sizeof (quote_transtab) - 2;
+       p > quote_transtab; p -= 2)
+    {
+      if (*p == c)
+	return p[-1];
+    }
+  return -1;
 }
 
 #define to_num(c) \
@@ -2119,7 +1244,7 @@ wordsplit_c_quoted_length (const char *str, int quote_hex, int *quote)
 	len += 3;
       else
 	{
-	  if (wordsplit_c_quote_char (*str))
+	  if (wordsplit_c_quote_char (*str) != -1)
 	    len += 2;
 	  else
 	    len += 4;
@@ -2128,56 +1253,47 @@ wordsplit_c_quoted_length (const char *str, int quote_hex, int *quote)
   return len;
 }
 
-static int
-wsplt_unquote_char (const char *transtab, int c)
+void
+wordsplit_general_unquote_copy (char *dst, const char *src, size_t n,
+				   const char *escapable)
 {
-  while (*transtab && transtab[1])
-    {
-      if (*transtab++ == c)
-	return *transtab;
-      ++transtab;
-    }
-  return 0;
-}
+  int i;
 
-static int
-wsplt_quote_char (const char *transtab, int c)
-{
-  for (; *transtab && transtab[1]; transtab += 2)
+  for (i = 0; i < n;)
     {
-      if (transtab[1] == c)
-	return *transtab;
+      if (src[i] == '\\' && i < n && strchr (escapable, src[i + 1]))
+	i++;
+      *dst++ = src[i++];
     }
-  return 0;
+  *dst = 0;
 }
 
-int
-wordsplit_c_unquote_char (int c)
+void
+wordsplit_sh_unquote_copy (char *dst, const char *src, size_t n)
 {
-  return wsplt_unquote_char (wordsplit_c_escape_tab, c);
-}
+  int i;
 
-int
-wordsplit_c_quote_char (int c)
-{
-  return wsplt_quote_char (wordsplit_c_escape_tab, c);
+  for (i = 0; i < n;)
+    {
+      if (src[i] == '\\')
+	i++;
+      *dst++ = src[i++];
+    }
+  *dst = 0;
 }
 
 void
-wordsplit_string_unquote_copy (struct wordsplit *ws, int inquote,
-			       char *dst, const char *src, size_t n)
+wordsplit_c_unquote_copy (char *dst, const char *src, size_t n)
 {
   int i = 0;
   int c;
 
-  inquote = !!inquote;
   while (i < n)
     {
       if (src[i] == '\\')
 	{
 	  ++i;
-	  if (WRDSO_ESC_TEST (ws, inquote, WRDSO_XESC)
-	      && (src[i] == 'x' || src[i] == 'X'))
+	  if (src[i] == 'x' || src[i] == 'X')
 	    {
 	      if (n - i < 2)
 		{
@@ -2200,8 +1316,7 @@ wordsplit_string_unquote_copy (struct wordsplit *ws, int inquote,
 		    }
 		}
 	    }
-	  else if (WRDSO_ESC_TEST (ws, inquote, WRDSO_OESC)
-		   && (unsigned char) src[i] < 128 && ISDIGIT (src[i]))
+	  else if ((unsigned char) src[i] < 128 && ISDIGIT (src[i]))
 	    {
 	      if (n - i < 1)
 		{
@@ -2223,17 +1338,8 @@ wordsplit_string_unquote_copy (struct wordsplit *ws, int inquote,
 		    }
 		}
 	    }
-	  else if ((c = wsplt_unquote_char (ws->ws_escape[inquote], src[i])))
-	    {
-	      *dst++ = c;
-	      ++i;
-	    }
 	  else
-	    {
-	      if (WRDSO_ESC_TEST (ws, inquote, WRDSO_BSKEEP))
-		*dst++ = '\\';
-	      *dst++ = src[i++];
-	    }
+	    *dst++ = wordsplit_c_unquote_char (src[i++]);
 	}
       else
 	*dst++ = src[i++];
@@ -2267,7 +1373,7 @@ wordsplit_c_quote_copy (char *dst, const char *src, int quote_hex)
 	    {
 	      int c = wordsplit_c_quote_char (*src);
 	      *dst++ = '\\';
-	      if (c)
+	      if (c != -1)
 		*dst++ = c;
 	      else
 		{
@@ -2280,82 +1386,20 @@ wordsplit_c_quote_copy (char *dst, const char *src, int quote_hex)
     }
 }
 
-
-/* This structure describes a single expansion phase */
-struct exptab
-{
-  char const *descr; /* Textual description (for debugging) */
-  int flag;          /* WRDSF_ bit that controls this phase */
-  int opt;           /* Entry-specific options (see EXPOPT_ flags below */
-  int (*expansion) (struct wordsplit *wsp); /* expansion function */
-};
-
-/* The following options control expansions: */
-/* Normally the exptab entry is run if its flag bit is set in struct
-   wordsplit.  The EXPOPT_NEG option negates this test so that expansion
-   is performed if its associated flag bit is not set in struct wordsplit. */
-#define EXPOPT_NEG      0x01
-/* All bits in flag must be set in order for entry to match */
-#define EXPORT_ALLOF    0x02
-/* Coalesce the input list before running the expansion. */
-#define EXPOPT_COALESCE 0x04
-
-static struct exptab exptab[] = {
-  { N_("WS trimming"),          WRDSF_WS,         0,
-    wordsplit_trimws },
-  { N_("command substitution"), WRDSF_NOCMD,      EXPOPT_NEG|EXPOPT_COALESCE,
-    wordsplit_cmdexp },
-  { N_("coalesce list"),        0,                EXPOPT_NEG|EXPOPT_COALESCE,
-    NULL },
-  { N_("tilde expansion"),      WRDSF_PATHEXPAND, 0,
-    wordsplit_tildexpand },
-  { N_("variable expansion"),   WRDSF_NOVAR,      EXPOPT_NEG,
-    wordsplit_varexp },
-  { N_("quote removal"),        0,                EXPOPT_NEG,
-    wsnode_quoteremoval },
-  { N_("coalesce list"),        0,                EXPOPT_NEG|EXPOPT_COALESCE,
-    NULL },
-  { N_("path expansion"),       WRDSF_PATHEXPAND, 0,
-    wordsplit_pathexpand },
-  { NULL }
-};
-
-static inline int
-exptab_matches(struct exptab *p, struct wordsplit *wsp)
-{
-  int result;
-
-  result = (wsp->ws_flags & p->flag);
-  if (p->opt & EXPORT_ALLOF)
-    result = result == p->flag;
-  if (p->opt & EXPOPT_NEG)
-    result = !result;
-
-  return result;
-}
-
 static int
 wordsplit_process_list (struct wordsplit *wsp, size_t start)
 {
-  struct exptab *p;
-
-  if (wsp->ws_flags & WRDSF_SHOWDBG)
-    wsp->ws_debug (_("(%02d) Input:%.*s;"),
-		   wsp->ws_lvl, (int) wsp->ws_len, wsp->ws_input);
-  
-  if ((wsp->ws_flags & WRDSF_NOSPLIT)
-      || ((wsp->ws_options & WRDSO_MAXWORDS)
-	  && wsp->ws_wordi + 1 == wsp->ws_maxwords))
-    {
-      /* Treat entire input as a single word */
-      if (scan_word (wsp, start, 1) == _WRDS_ERR)
+  if (wsp->ws_flags & WRDSF_NOSPLIT)
+    {
+      /* Treat entire input as a quoted argument */
+      if (wordsplit_add_segm (wsp, start, wsp->ws_len, _WSNF_QUOTE))
 	return wsp->ws_errno;
     }
   else
     {
       int rc;
 
-      while ((rc = scan_word (wsp, start, 0)) == _WRDS_OK)
+      while ((rc = scan_word (wsp, start)) == _WRDS_OK)
 	start = skip_delim (wsp);
       /* Make sure tail element is not joinable */
       if (wsp->ws_tail)
@@ -2366,88 +1410,132 @@ wordsplit_process_list (struct wordsplit *wsp, size_t start)
 
   if (wsp->ws_flags & WRDSF_SHOWDBG)
     {
-      wsp->ws_debug ("(%02d) %s", wsp->ws_lvl, _("Initial list:"));
+      wsp->ws_debug ("Initial list:");
       wordsplit_dump_nodes (wsp);
     }
 
-  for (p = exptab; p->descr; p++)
+  if (wsp->ws_flags & WRDSF_WS)
     {
-      if (exptab_matches(p, wsp))
+      /* Trim leading and trailing whitespace */
+      wordsplit_trimws (wsp);
+      if (wsp->ws_flags & WRDSF_SHOWDBG)
 	{
-	  if (p->opt & EXPOPT_COALESCE)
-	    {
-	      if (wsnode_coalesce (wsp))
-		break;
-	      if (wsp->ws_flags & WRDSF_SHOWDBG)
-		{
-		  wsp->ws_debug ("(%02d) %s", wsp->ws_lvl,
-				 _("Coalesced list:"));
-		  wordsplit_dump_nodes (wsp);
-		}
-	    }
-	  if (p->expansion)
-	    {
-	      if (p->expansion (wsp))
-		break;
-	      if (wsp->ws_flags & WRDSF_SHOWDBG)
-		{
-		  wsp->ws_debug ("(%02d) %s", wsp->ws_lvl, _(p->descr));
-		  wordsplit_dump_nodes (wsp);
-		}
-	    }
+	  wsp->ws_debug ("After WS trimming:");
+	  wordsplit_dump_nodes (wsp);
+	}
+    }
+
+  /* Expand variables (FIXME: & commands) */
+  if (!(wsp->ws_flags & WRDSF_NOVAR))
+    {
+      if (wordsplit_varexp (wsp))
+	{
+	  wordsplit_free_nodes (wsp);
+	  return wsp->ws_errno;
+	}
+      if (wsp->ws_flags & WRDSF_SHOWDBG)
+	{
+	  wsp->ws_debug ("Expanded list:");
+	  wordsplit_dump_nodes (wsp);
+	}
+    }
+
+  do
+    {
+      if (wsnode_quoteremoval (wsp))
+	break;
+      if (wsp->ws_flags & WRDSF_SHOWDBG)
+	{
+	  wsp->ws_debug ("After quote removal:");
+	  wordsplit_dump_nodes (wsp);
+	}
+
+      if (wsnode_coalesce (wsp))
+	break;
+
+      if (wsp->ws_flags & WRDSF_SHOWDBG)
+	{
+	  wsp->ws_debug ("Coalesced list:");
+	  wordsplit_dump_nodes (wsp);
 	}
     }
+  while (0);
   return wsp->ws_errno;
 }
 
-static int
-wordsplit_run (const char *command, size_t length, struct wordsplit *wsp,
-               unsigned flags, int lvl)
+int
+wordsplit_len (const char *command, size_t length, struct wordsplit *wsp,
+               int flags)
 {
   int rc;
   size_t start;
+  const char *cmdptr;
+  size_t cmdlen;
 
   if (!command)
     {
       if (!(flags & WRDSF_INCREMENTAL))
-	return _wsplt_seterr (wsp, WRDSE_USAGE);
-
-      if (wsp->ws_head)
-	return wordsplit_finish (wsp);
+	return EINVAL;
 
-      start = skip_delim_real (wsp);
+      start = skip_delim (wsp);
       if (wsp->ws_endp == wsp->ws_len)
-	return _wsplt_seterr (wsp, WRDSE_NOINPUT);
+	{
+	  wsp->ws_errno = WRDSE_NOINPUT;
+	  if (wsp->ws_flags & WRDSF_SHOWERR)
+	    wordsplit_perror (wsp);
+	  return wsp->ws_errno;
+	}
 
+      cmdptr = wsp->ws_input + wsp->ws_endp;
+      cmdlen = wsp->ws_len - wsp->ws_endp;
       wsp->ws_flags |= WRDSF_REUSE;
       wordsplit_init0 (wsp);
     }
   else
     {
+      cmdptr = command;
+      cmdlen = length;
       start = 0;
-      rc = wordsplit_init (wsp, command, length, flags);
+      rc = wordsplit_init (wsp, cmdptr, cmdlen, flags);
       if (rc)
 	return rc;
-      wsp->ws_lvl = lvl;
     }
 
+  if (wsp->ws_flags & WRDSF_SHOWDBG)
+    wsp->ws_debug ("Input:%.*s;", (int) cmdlen, cmdptr);
+
   rc = wordsplit_process_list (wsp, start);
+  if (rc == 0 && (flags & WRDSF_INCREMENTAL))
+    {
+      while (!wsp->ws_head && wsp->ws_endp < wsp->ws_len)
+	{
+	  start = skip_delim (wsp);
+	  if (wsp->ws_flags & WRDSF_SHOWDBG)
+	    {
+	      cmdptr = wsp->ws_input + wsp->ws_endp;
+	      cmdlen = wsp->ws_len - wsp->ws_endp;
+	      wsp->ws_debug ("Restart:%.*s;", (int) cmdlen, cmdptr);
+	    }
+	  rc = wordsplit_process_list (wsp, start);
+	  if (rc)
+	    break;
+	}
+    }
   if (rc)
-    return rc;
-  return wordsplit_finish (wsp);
-}
-
-int
-wordsplit_len (const char *command, size_t length, struct wordsplit *wsp, 
-               unsigned flags)
-{
-  return wordsplit_run (command, length, wsp, flags, 0);
+    {
+      wordsplit_free_nodes (wsp);
+      return rc;
+    }
+  wordsplit_finish (wsp);
+  wordsplit_free_nodes (wsp);
+  return wsp->ws_errno;
 }
 
 int
-wordsplit (const char *command, struct wordsplit *ws, unsigned flags)
+wordsplit (const char *command, struct wordsplit *ws, int flags)
 {
-  return wordsplit_len (command, command ? strlen (command) : 0, ws, flags);
+  return wordsplit_len (command, command ? strlen (command) : 0, ws,
+			   flags);
 }
 
 void
@@ -2467,69 +1555,67 @@ wordsplit_free_words (struct wordsplit *ws)
   ws->ws_wordc = 0;
 }
 
-void
-wordsplit_free_envbuf (struct wordsplit *ws)
-{
-  if (ws->ws_flags & WRDSF_NOCMD)
-    return;
-  if (ws->ws_envbuf)
-    {
-      size_t i;
-
-      for (i = 0; ws->ws_envbuf[i]; i++)
-	free (ws->ws_envbuf[i]);
-      free (ws->ws_envbuf);
-      ws->ws_envidx = ws->ws_envsiz = 0;
-      ws->ws_envbuf = NULL;
-    }
-}
-
-void
-wordsplit_clearerr (struct wordsplit *ws)
-{
-  if (ws->ws_errno == WRDSE_USERERR)
-    free (ws->ws_usererr);
-  ws->ws_usererr = NULL;
-  ws->ws_errno = WRDSE_OK;
-}
-
 void
 wordsplit_free (struct wordsplit *ws)
 {
-  wordsplit_free_nodes (ws);
   wordsplit_free_words (ws);
   free (ws->ws_wordv);
   ws->ws_wordv = NULL;
-  wordsplit_free_envbuf (ws);
 }
 
-int
-wordsplit_get_words (struct wordsplit *ws, size_t *wordc, char ***wordv)
+void
+wordsplit_perror (struct wordsplit *wsp)
 {
-  char **p = realloc (ws->ws_wordv,
-		      (ws->ws_wordc + 1) * sizeof (ws->ws_wordv[0]));
-  if (!p)
-    return -1;
-  *wordv = p;
-  *wordc = ws->ws_wordc;
+  switch (wsp->ws_errno)
+    {
+    case WRDSE_EOF:
+      wsp->ws_error (_("no error"));
+      break;
 
-  ws->ws_wordv = NULL;
-  ws->ws_wordc = 0;
-  ws->ws_wordn = 0;
+    case WRDSE_QUOTE:
+      wsp->ws_error (_("missing closing %c (start near #%lu)"),
+		     wsp->ws_input[wsp->ws_endp],
+		     (unsigned long) wsp->ws_endp);
+      break;
 
-  return 0;
+    case WRDSE_NOSPACE:
+      wsp->ws_error (_("memory exhausted"));
+      break;
+
+    case WRDSE_NOSUPP:
+      wsp->ws_error (_("command substitution is not yet supported"));
+      break;
+
+    case WRDSE_USAGE:
+      wsp->ws_error (_("invalid wordsplit usage"));
+      break;
+
+    case WRDSE_CBRACE:
+      wsp->ws_error (_("unbalanced curly brace"));
+      break;
+
+    case WRDSE_UNDEF:
+      wsp->ws_error (_("undefined variable"));
+      break;
+
+    case WRDSE_NOINPUT:
+      wsp->ws_error (_("input exhausted"));
+      break;
+
+    default:
+      wsp->ws_error (_("unknown error"));
+    }
 }
 
 const char *_wordsplit_errstr[] = {
   N_("no error"),
   N_("missing closing quote"),
   N_("memory exhausted"),
+  N_("command substitution is not yet supported"),
   N_("invalid wordsplit usage"),
   N_("unbalanced curly brace"),
   N_("undefined variable"),
-  N_("input exhausted"),
-  N_("unbalanced parenthesis"),
-  N_("globbing error")
+  N_("input exhausted")
 };
 int _wordsplit_nerrs =
   sizeof (_wordsplit_errstr) / sizeof (_wordsplit_errstr[0]);
@@ -2537,26 +1623,7 @@ int _wordsplit_nerrs =
 const char *
 wordsplit_strerror (struct wordsplit *ws)
 {
-  if (ws->ws_errno == WRDSE_USERERR)
-    return ws->ws_usererr;
   if (ws->ws_errno < _wordsplit_nerrs)
     return _wordsplit_errstr[ws->ws_errno];
   return N_("unknown error");
 }
-
-void
-wordsplit_perror (struct wordsplit *wsp)
-{
-  switch (wsp->ws_errno)
-    {
-    case WRDSE_QUOTE:
-      wsp->ws_error (_("missing closing %c (start near #%lu)"),
-		     wsp->ws_input[wsp->ws_endp],
-		     (unsigned long) wsp->ws_endp);
-      break;
-
-    default:
-      wsp->ws_error ("%s", wordsplit_strerror (wsp));
-    }
-}
-
diff --git a/lib/wordsplit.h b/lib/wordsplit.h
index ff7f6e3..575865b 100644
--- a/lib/wordsplit.h
+++ b/lib/wordsplit.h
@@ -1,5 +1,5 @@
 /* wordsplit - a word splitter
-   Copyright (C) 2009-2018 Sergey Poznyakoff
+   Copyright (C) 2009-2014, 2016-2017 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
@@ -12,7 +12,10 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License along
-   with this program. If not, see <http://www.gnu.org/licenses/>. */
+   with this program. If not, see <http://www.gnu.org/licenses/>.
+
+   Written by Sergey Poznyakoff
+*/
 
 #ifndef __WORDSPLIT_H
 #define __WORDSPLIT_H
@@ -25,106 +28,42 @@
 # define __WORDSPLIT_ATTRIBUTE_FORMAT(spec) /* empty */
 #endif
 
-typedef struct wordsplit wordsplit_t;
-
-/* Structure used to direct the splitting.  Members marked with [Input]
-   can be defined before calling wordsplit(), those marked with [Output]
-   provide return values when the function returns.  If neither mark is
-   used, the member is internal and must not be used by the caller.
-
-   In the comments below, the identifiers in parentheses indicate bits that
-   must be set (or unset, if starting with !) in ws_flags (if starting with
-   WRDSF_) or ws_options (if starting with WRDSO_) to initialize or use the
-   given member.
-   
-   If not redefined explicitly, most of them are set to some reasonable
-   default value upon entry to wordsplit(). */
-struct wordsplit            
+struct wordsplit
 {
-  size_t ws_wordc;          /* [Output] Number of words in ws_wordv. */
-  char **ws_wordv;          /* [Output] Array of parsed out words. */
-  size_t ws_offs;           /* [Input] (WRDSF_DOOFFS) Number of initial
-			       elements in ws_wordv to fill with NULLs. */
-  size_t ws_wordn;          /* Number of elements ws_wordv can accomodate. */ 
-  unsigned ws_flags;        /* [Input] Flags passed to wordsplit. */
-  unsigned ws_options;      /* [Input] (WRDSF_OPTIONS)
-			       Additional options. */
-  size_t ws_maxwords;       /* [Input] (WRDSO_MAXWORDS) Return at most that
-			       many words */
-  size_t ws_wordi;          /* [Output] (WRDSF_INCREMENTAL) Total number of
-			       words returned so far */
-
-  const char *ws_delim;     /* [Input] (WRDSF_DELIM) Word delimiters. */
-  const char *ws_comment;   /* [Input] (WRDSF_COMMENT) Comment characters. */
-  const char *ws_escape[2]; /* [Input] (WRDSF_ESCAPE) Characters to be escaped
-			       with backslash. */
-  void (*ws_alloc_die) (wordsplit_t *wsp);
-                            /* [Input] (WRDSF_ALLOC_DIE) Function called when
-			       out of memory.  Must not return. */
+  size_t ws_wordc;
+  char **ws_wordv;
+  size_t ws_offs;
+  size_t ws_wordn;
+  int ws_flags;
+  const char *ws_delim;
+  const char *ws_comment;
+  const char *ws_escape;
+  void (*ws_alloc_die) (struct wordsplit * wsp);
   void (*ws_error) (const char *, ...)
-                   __attribute__ ((__format__ (__printf__, 1, 2)));
-                            /* [Input] (WRDSF_ERROR) Function used for error
-			       reporting */
+    __WORDSPLIT_ATTRIBUTE_FORMAT ((__printf__, 1, 2));
   void (*ws_debug) (const char *, ...)
-                   __attribute__ ((__format__ (__printf__, 1, 2)));
-                            /* [Input] (WRDSF_DEBUG) Function used for debug
-			       output. */
-  const char **ws_env;      /* [Input] (WRDSF_ENV, !WRDSF_NOVAR) Array of
-			       environment variables. */
+    __WORDSPLIT_ATTRIBUTE_FORMAT ((__printf__, 1, 2));
 
-  char **ws_envbuf;
-  size_t ws_envidx;
-  size_t ws_envsiz;
-  
-  int (*ws_getvar) (char **ret, const char *var, size_t len, void *clos);
-                            /* [Input] (WRDSF_GETVAR, !WRDSF_NOVAR) Looks up
-			       the name VAR (LEN bytes long) in the table of
-			       variables and if found returns in memory
-			       location pointed to by RET the value of that
-			       variable.  Returns WRDSE_OK (0) on success,
-			       and an error code (see WRDSE_* defines below)
-			       on error.  User-specific errors can be returned
-			       by storing the error diagnostic string in RET
-			       and returning WRDSE_USERERR.
-                               Whatever is stored in RET, it must be allocated
-			       using malloc(3). */
-  void *ws_closure;         /* [Input] (WRDSF_CLOSURE) Passed as the CLOS
-			       argument to ws_getvar and ws_command. */
-  int (*ws_command) (char **ret, const char *cmd, size_t len, char **argv,
-                     void *clos);
-	                    /* [Input] (!WRDSF_NOCMD) Returns in the memory
-			       location pointed to by RET the expansion of
-			       the command CMD (LEN bytes long).  If WRDSO_ARGV
-			       option is set, ARGV contains CMD split out to
-			       words.  Otherwise ARGV is NULL.
+  const char **ws_env;
+  const char *(*ws_getvar) (const char *, size_t, void *);
+  void *ws_closure;
 
-			       See ws_getvar for a discussion of possible
-			       return values. */
-	
-  const char *ws_input;     /* Input string (the S argument to wordsplit. */  
-  size_t ws_len;            /* Length of ws_input. */
-  size_t ws_endp;           /* Points past the last processed byte in
-			       ws_input. */
-  int ws_errno;             /* [Output] Error code, if an error occurred. */
-  char *ws_usererr;         /* Points to textual description of
-			       the error, if ws_errno is WRDSE_USERERR.  Must
-			       be allocated with malloc(3). */
+  const char *ws_input;
+  size_t ws_len;
+  size_t ws_endp;
+  int ws_errno;
   struct wordsplit_node *ws_head, *ws_tail;
-                            /* Doubly-linked list of parsed out nodes. */
-  int ws_lvl;               /* Invocation nesting level. */
 };
 
-/* Initial size for ws_env, if allocated automatically */
-#define WORDSPLIT_ENV_INIT 16
-
-/* Wordsplit flags. */
+/* Wordsplit flags.  Only 2 bits of a 32-bit word remain unused.
+   It is getting crowded... */
 /* Append the words found to the array resulting from a previous
    call. */
 #define WRDSF_APPEND            0x00000001
-/* Insert ws_offs initial NULLs in the array ws_wordv.
+/* Insert we_offs initial NULLs in the array ws_wordv.
    (These are not counted in the returned ws_wordc.) */
 #define WRDSF_DOOFFS            0x00000002
-/* Don't do command substitution. */
+/* Don't do command substitution. Reserved for future use. */
 #define WRDSF_NOCMD             0x00000004
 /* The parameter p resulted from a previous call to
    wordsplit(), and wordsplit_free() was not called. Reuse the
@@ -132,8 +71,10 @@ struct wordsplit
 #define WRDSF_REUSE             0x00000008
 /* Print errors */
 #define WRDSF_SHOWERR           0x00000010
-/* Consider it an error if an undefined variable is expanded. */
+/* Consider it an error if an undefined shell variable
+   is expanded. */
 #define WRDSF_UNDEF             0x00000020
+
 /* Don't do variable expansion. */
 #define WRDSF_NOVAR             0x00000040
 /* Abort on ENOMEM error */
@@ -144,7 +85,7 @@ struct wordsplit
 #define WRDSF_SQUOTE            0x00000200
 /* Handle double quotes */
 #define WRDSF_DQUOTE            0x00000400
-/* Handle single and double quotes */
+/* Handle quotes and escape directives */
 #define WRDSF_QUOTE             (WRDSF_SQUOTE|WRDSF_DQUOTE)
 /* Replace each input sequence of repeated delimiters with a single
    delimiter */
@@ -172,106 +113,56 @@ struct wordsplit
 /* Don't split input into words.  Useful for side effects. */
 #define WRDSF_NOSPLIT           0x00400000
 /* Keep undefined variables in place, instead of expanding them to
-   empty strings. */
+   empty string */
 #define WRDSF_KEEPUNDEF         0x00800000
 /* Warn about undefined variables */
 #define WRDSF_WARNUNDEF         0x01000000
 /* Handle C escapes */
 #define WRDSF_CESCAPES          0x02000000
+
 /* ws_closure is set */
 #define WRDSF_CLOSURE           0x04000000
 /* ws_env is a Key/Value environment, i.e. the value of a variable is
    stored in the element that follows its name. */
 #define WRDSF_ENV_KV            0x08000000
+
 /* ws_escape is set */
 #define WRDSF_ESCAPE            0x10000000
+
 /* Incremental mode */
 #define WRDSF_INCREMENTAL       0x20000000
-/* Perform pathname and tilde expansion */
-#define WRDSF_PATHEXPAND        0x40000000
-/* ws_options is initialized */
-#define WRDSF_OPTIONS           0x80000000
 
 #define WRDSF_DEFFLAGS	       \
   (WRDSF_NOVAR | WRDSF_NOCMD | \
    WRDSF_QUOTE | WRDSF_SQUEEZE_DELIMS | WRDSF_CESCAPES)
 
-/* Remove the word that produces empty string after path expansion */
-#define WRDSO_NULLGLOB        0x00000001
-/* Print error message if path expansion produces empty string */
-#define WRDSO_FAILGLOB        0x00000002
-/* Allow a leading period to be matched by metacharacters. */
-#define WRDSO_DOTGLOB         0x00000004
-/* ws_command needs argv parameter */
-#define WRDSO_ARGV            0x00000008
-/* Keep backslash in unrecognized escape sequences in words */
-#define WRDSO_BSKEEP_WORD     0x00000010
-/* Handle octal escapes in words */
-#define WRDSO_OESC_WORD       0x00000020
-/* Handle hex escapes in words */
-#define WRDSO_XESC_WORD       0x00000040
-
-/* ws_maxwords field is initialized */
-#define WRDSO_MAXWORDS        0x00000080
-
-/* Keep backslash in unrecognized escape sequences in quoted strings */
-#define WRDSO_BSKEEP_QUOTE    0x00000100
-/* Handle octal escapes in quoted strings */
-#define WRDSO_OESC_QUOTE      0x00000200
-/* Handle hex escapes in quoted strings */
-#define WRDSO_XESC_QUOTE      0x00000400
-
-#define WRDSO_BSKEEP          WRDSO_BSKEEP_WORD     
-#define WRDSO_OESC            WRDSO_OESC_WORD       
-#define WRDSO_XESC            WRDSO_XESC_WORD       
-
-/* Indices into ws_escape */
-#define WRDSX_WORD  0
-#define WRDSX_QUOTE 1
-
-/* Set escape option F in WS for words (Q==0) or quoted strings (Q==1) */
-#define WRDSO_ESC_SET(ws,q,f) ((ws)->ws_options |= ((f) << 4*(q)))
-/* Test WS for escape option F for words (Q==0) or quoted strings (Q==1) */
-#define WRDSO_ESC_TEST(ws,q,f) ((ws)->ws_options & ((f) << 4*(q)))
-
-#define WRDSE_OK         0
-#define WRDSE_EOF        WRDSE_OK
+#define WRDSE_EOF        0
 #define WRDSE_QUOTE      1
 #define WRDSE_NOSPACE    2
-#define WRDSE_USAGE      3
-#define WRDSE_CBRACE     4
-#define WRDSE_UNDEF      5
-#define WRDSE_NOINPUT    6
-#define WRDSE_PAREN      7
-#define WRDSE_GLOBERR    8
-#define WRDSE_USERERR    9
-
-int wordsplit (const char *s, wordsplit_t *ws, unsigned flags);
-int wordsplit_len (const char *s, size_t len, wordsplit_t *ws, unsigned flags);
-void wordsplit_free (wordsplit_t *ws);
-void wordsplit_free_words (wordsplit_t *ws);
-void wordsplit_free_envbuf (wordsplit_t *ws);
-int wordsplit_get_words (wordsplit_t *ws, size_t *wordc, char ***wordv);
-
-static inline void wordsplit_getwords (wordsplit_t *ws, size_t *wordc, char ***wordv)
-  __attribute__ ((deprecated));
-
-static inline void
-wordsplit_getwords (wordsplit_t *ws, size_t *wordc, char ***wordv)
-{
-  wordsplit_get_words (ws, wordc, wordv);
-}
-
-int wordsplit_append (wordsplit_t *wsp, int argc, char **argv);
+#define WRDSE_NOSUPP     3
+#define WRDSE_USAGE      4
+#define WRDSE_CBRACE     5
+#define WRDSE_UNDEF      6
+#define WRDSE_NOINPUT    7
+
+int wordsplit (const char *s, struct wordsplit *p, int flags);
+int wordsplit_len (const char *s, size_t len,
+		      struct wordsplit *p, int flags);
+void wordsplit_free (struct wordsplit *p);
+void wordsplit_free_words (struct wordsplit *ws);
 
 int wordsplit_c_unquote_char (int c);
 int wordsplit_c_quote_char (int c);
-size_t wordsplit_c_quoted_length (const char *str, int quote_hex, int *quote);
+size_t wordsplit_c_quoted_length (const char *str, int quote_hex,
+				  int *quote);
+void wordsplit_general_unquote_copy (char *dst, const char *src, size_t n,
+				     const char *escapable);
+void wordsplit_sh_unquote_copy (char *dst, const char *src, size_t n);
+void wordsplit_c_unquote_copy (char *dst, const char *src, size_t n);
 void wordsplit_c_quote_copy (char *dst, const char *src, int quote_hex);
 
-void wordsplit_perror (wordsplit_t *ws);
-const char *wordsplit_strerror (wordsplit_t *ws);
+void wordsplit_perror (struct wordsplit *ws);
+const char *wordsplit_strerror (struct wordsplit *ws);
 
-void wordsplit_clearerr (wordsplit_t *ws);
 
 #endif
